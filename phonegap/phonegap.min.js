/**
 * This represents the PhoneGap API itself, and provides a global namespace for accessing
 * information about the state of PhoneGap.
 * @class
 */
PhoneGap = {
queue: {
ready: true,
commands: [],
timer: null
},
_constructors: []
};

PhoneGap.addConstructor = function(func) 
{
    var state = document.readyState;
    
	//if ( ( state == 'loaded' || state == 'complete' ) && DeviceInfo.uuid != null )
	{
		//	func();
	}
    //else
	{
        PhoneGap._constructors.push(func);
	}
};

/**
 * Add an initialization function to a queue that ensures it will run and initialize
 * application constructors only once PhoneGap has been initialized.
 * @param {Function} func The function callback you want run once PhoneGap is initialized
 */

(function() 
 {
 var timer = setInterval(function()
						 {
						 
						 var state = document.readyState;
						 
						 if ( ( state == 'loaded' || state == 'complete' ) )
						 {
						 clearInterval(timer); // stop looking
						 // run our constructors list
						 while (PhoneGap._constructors.length > 0) 
						 {
						 var constructor = PhoneGap._constructors.shift();
						 try 
						 {
						 constructor();
						 } 
						 catch(e) 
						 {
						 if (typeof(debug['log']) == 'function')
						 {
						 debug.log("Failed to run constructor: " + debug.processMessage(e));
						 }
						 else
						 {
						 alert("Failed to run constructor: " + e.message);
						 }
						 }
						 }
						 // all constructors run, now fire the deviceready event
						 var e = document.createEvent('Events'); 
						 e.initEvent('deviceready');
						 document.dispatchEvent(e);
						 }
						 }, 1);
 })();


/**
 * Execute a PhoneGap command in a queued fashion, to ensure commands do not
 * execute with any race conditions, and only run when PhoneGap is ready to
 * recieve them.
 * @param {String} command Command to be run in PhoneGap, e.g. "ClassName.method"
 * @param {String[]} [args] Zero or more arguments to pass to the method
 */
PhoneGap.exec = function() {
    PhoneGap.queue.commands.push(arguments);
    if (PhoneGap.queue.timer == null)
        PhoneGap.queue.timer = setInterval(PhoneGap.run_command, 10);
};

/**
 * Internal function used to dispatch the request to PhoneGap.  It processes the
 * command queue and executes the next command on the list.  If one of the
 * arguments is a JavaScript object, it will be passed on the QueryString of the
 * url, which will be turned into a dictionary on the other end.
 * @private
 */
PhoneGap.run_command = function() 
{
    
	if (!PhoneGap.queue.ready) return;
	
    PhoneGap.queue.ready = false;
	
    var args = PhoneGap.queue.commands.shift();
	
	//alert("arg="+args);
	
    if (PhoneGap.queue.commands.length == 0) {
        clearInterval(PhoneGap.queue.timer);
        PhoneGap.queue.timer = null;
    }
	
    var uri = [];
    var dict = null;
    for (var i = 1; i < args.length; i++) {
        var arg = args[i];
        if (arg == undefined || arg == null)
            arg = '';
        if (typeof(arg) == 'object')
            dict = arg;
        else
            uri.push(encodeURIComponent(arg));
    }
    var url = "gap://" + args[0] + "/" + uri.join("/");
    if (dict != null) {
        var query_args = [];
        for (var name in dict) {
            if (typeof(name) != 'string')
                continue;
            query_args.push(encodeURIComponent(name) + "=" + encodeURIComponent(dict[name]));
        }
        if (query_args.length > 0)
            url += "?" + query_args.join("&");
    }
    document.location = url;
	
};


function Camera() {
	
}


Camera.prototype.getPicture = function(successCallback, errorCallback, options) 
{
	alert('get');
	PhoneGap.exec("Camera.getPicture", GetFunctionName(successCallback), GetFunctionName(errorCallback), options);
}

PhoneGap.addConstructor(function() 
{
	if (typeof navigator.camera == "undefined") navigator.camera = new Camera();
});

// Gets the function name of a Function object, else uses "alert" if anonymous
function GetFunctionName(fn)
{
	if (fn) {
		var m = fn.toString().match(/^\s*function\s+([^\s\(]+)/);
													  return m ? m[1] : "alert";
													  } else {
													  return null;
													  }
													  }


		/**
		 * This class provides access to the device SMS functionality.
		 * @constructor
		 */
function Sms() {					  
				}
													  
		/**
		 * Sends an SMS message.
		 * @param {Integer} number The phone number to send the message to.
		 * @param {String} message The contents of the SMS message to send.
		 * @param {Function} successCallback The function to call when the SMS message is sent.
		 * @param {Function} errorCallback The function to call when there is an error sending the SMS message.
		 * @param {PositionOptions} options The options for accessing the GPS location such as timeout and accuracy.
		 */
													  Sms.prototype.send = function(number, message, successCallback, errorCallback, options) {
													  
													  }
													  
													  PhoneGap.addConstructor(function() {
																			  if (typeof navigator.sms == "undefined") navigator.sms = new Sms();
																			  });
		/**
		 * This class provides access to the telephony features of the device.
		 * @constructor
		 */
													  function Telephony() {
													  
													  }
													  
		/**
		 * Calls the specifed number.
		 * @param {Integer} number The number to be called.
		 */
													  Telephony.prototype.call = function(number) {
													  
													  }
													  
													  PhoneGap.addConstructor(function() {
																			  if (typeof navigator.telephony == "undefined") navigator.telephony = new Telephony();
																			  });
													  
